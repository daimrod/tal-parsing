;;; tal-parsing.el ---

;; Copyright (C) 2014 Grégoire Jadi

;; Author: Grégoire Jadi <gregoire.jadi@gmail.com>

;; This program is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

(require 'cl)

(defstruct tal/tag
  initial-trees
  auxiliary-trees)

(defun tal/initialize-array (size)
  "Initialize the array used by the algorithm.

It's a four dimentional array."
  (let ((ret (make-list size nil)))
    (dotimes (i size)
      (setf (elt ret i) (make-list size nil))
      (dotimes (j size)
        (setf (elt (elt ret i) j) (make-list size nil))
        (dotimes (k size)
          (setf (elt (elt (elt ret i) j) k) (make-list size nil))
          (dotimes (l size)
            (setf (elt (elt (elt (elt ret i) j) k) l) (list))))))
    ret))

(defun tal/parsing (tag input)
  "Main entry point to parse the INPUT and determine whether it
can be generated by TAG."
  (let* ((n (length input))
         (A (tal/initialize-array (1+ n)))
         (input (cons '_ input)))       ; start input at 1
    (tal/init-frontier A tag input n)
    (tal/init-foot-nodes A tag input n)
    (loop for l from 0 to n
          do
          (loop for i downfrom l to 0
                do
                (loop for j from i to l
                      do
                      (loop for k downfrom l to j
                            do (if (and edebug-on
                                        (= i 0)
                                        (= j 1)
                                        (= k 2)
                                        (= l 3))
                                   (edebug))
                            do (tal/case-1 A tag input i j k l)
                            do (tal/case-2 A tag input i j k l)
                            do (tal/case-3 A tag input i j k l)
                            do (tal/case-5 A tag input i j k l)
                            do (tal/case-4 A tag input i j k l)))))
    (or (loop for j from 0 to n
              for intersection = (intersection (tal/tag-initial-trees tag)
                                               (elt (elt (elt (elt A 0)
                                                              j)
                                                         j)
                                                    n))
              if intersection
              do (return intersection))
        (list A 'bad))))

(defun tal/add-node-frontier (node input A i j k l)
  "Determine whether NODE ∈ A[i, j, k, l] for the given INPUT and
add it if it's the case.

We say a node X of a derived tree γ belongs to A[i, j, k, l] if X
dominates a sub-tree of γ whose frontier is given by either

 a_i+1 ... a_j Y a_k+1 ... l

 (where the foot node of γ is labelled by Y) or

 a_i+1 ... l

 (i.e j = k. This corresponds to the case when γ is
a sentential tree).

The indices (i, j, k, l) refer to the positions between the input
symbols and range over 0 through n. If i = 5 say, then it refers
to the gap beteen a_6 and a_l (or a_n or something I can't read
it)."
  (push (format "Try: %s ∈ A[%d, %d, %d, %d,]" (bt/node-pp node) i j k l)
            tmp/trace)
  (let ((frontier (mapcar #'bt/node-symbol (bt/leaves node 'terminal)))
        (n (length input))
        bool)
    ;; (setf bool (bt/node-p node))

    ;; ;; check the first part (i -> j)
    ;; (when bool
    ;;   (loop for x from (1+ i) to j
    ;;         for el = (pop frontier)
            
    ;;         if (or (not (eq el (elt input x)))
    ;;                (not el))
    ;;         do (setf bool nil)
            
    ;;         while bool))
    
    ;; ;; check the second part (k -> l)
    ;; (when bool
    ;;   (loop for x from (1+ k) to l 
    ;;         for el = (pop frontier)
            
    ;;         if (or (not (eq el (elt input x)))
    ;;                (not el))
    ;;         do (setf bool nil)
            
    ;;         while bool))

    ;; if it's okay, add the node to A[i, j, k, l]
    (push node (elt (elt (elt (elt A i) j) k) l))
    (push "OK"
          tmp/trace)
    ;; (when (and bool
    ;;            (not frontier)
    ;;            (not (find node (elt (elt (elt (elt A i) j) k) l))))
    ;;   (push node (elt (elt (elt (elt A i) j) k) l))
    ;;   (push "OK"
    ;;         tmp/trace))
    ))

(defun tal/case-1 (A tag input i j k l)
  "Case 1 corresponds to situation where the left sibling is the
ancestor of the foot node. The parent is put in A[i, j, k, l] if
the left sibling is in A[i, j, k, m] and the right sibling is in
A[m, p, p, l], where k <= m <= p, m <= p <= l."
  (push (format "tal/case-1 (%d, %d, %d, %d)" i j k l) tmp/trace)
  (loop for m from k to (1- l)
        do
        (loop for p from m to l
              ;; if left siblings in A[i, j, k, m] are an ancestor of
              ;; a foot node
              for left = (remove-if-not #'bt/node-foot-node-ancestor
                                        (elt (elt (elt (elt A i)
                                                       j)
                                                  k)
                                             m))
              ;; and their right siblings in A[m, p, p, l]
              for right = (remove-if (lambda (node)
                                       (or (bt/node-foot-node-ancestor node)
                                           (not (find (bt/node-sibling node 'left) left))))
                                     (elt (elt (elt (elt A m)
                                                    p)
                                               p)
                                          l))
              do
              ;; satisfying appropriate restrictions
              (loop for node in right
                    ;; then put their parent in A[i, j, k, l]
                    do (tal/add-node-frontier (bt/node-parent node)
                                              input
                                              A i j k l)))))

(defun tal/case-2 (A tag input i j k l)
  "Case 2 corresponds to the case where the right sibling is the
ancestor of the foot node. If the left sibling is in A[i, m, m,
p] and the right sibling is in A[p, j, k, l], i <= m <= p and m
<= p <= j, then we put their parent in A[i, j, k, l]."
  (push (format "tal/case-2 (%d, %d, %d, %d)" i j k l) tmp/trace)
  (loop for m from i to j
        do
        (loop for p from m to j
              ;; if right siblings in A[p, j, k, l] are an ancestor of
              ;; a foot node
              for right = (remove-if-not #'bt/node-foot-node-ancestor
                                         (elt (elt (elt (elt A p)
                                                        j)
                                                   k)
                                              l))

              ;; and their left siblings in A[i, m, m, p]
              for left = (remove-if (lambda (node)
                                      (or (bt/node-foot-node-ancestor node)
                                          (not (find (bt/node-sibling node 'right)
                                                     right))))
                                    (elt (elt (elt (elt A i)
                                                   m)
                                              m)
                                         p))


              do
              ;; satisfying appropriate restrictions
              (loop for node in left
                    ;; then put their parent in A[i, j, k, l]
                    do (tal/add-node-frontier (bt/node-parent node) input
                                              A i j k l)))))

(defun tal/case-3 (A tag input i j k l)
  "Case 3 corresponds to the case where neither children are
ancestors of the foot node. If the left sibling ∈ A[i, j, j, m]
and the right sibling ∈ A[m, p, p, l] then we can put the parent
in A[i, j, j, l]."
  (push (format "tal/case-3 (%d, %d, %d, %d)" i j k l) tmp/trace)
  (loop for m from i to l
        do
        (loop for p from m to l
              ;; for all left siblings in A[i, j, j, m]
              for left = (remove-if #'bt/node-foot-node-ancestor
                                    (elt (elt (elt (elt A i)
                                                   j)
                                              j)
                                         m))
              ;; and right siblings in A[m ,p, p, l]
              for right = (remove-if (lambda (node)
                                       (or (bt/node-foot-node-ancestor node)
                                           (not (find (bt/node-sibling node 'left) left))))
                                     (elt (elt (elt (elt A m)
                                                    p)
                                               p)
                                          l))
              ;; satisfying the appropriate restrictions
              do
              (loop for node in right
                    ;; put their parent in A[i, j, j, l]
                    do (tal/add-node-frontier (bt/node-parent node) input
                                              A i j j l)))))

(defun tal/case-4 (A tag input i j k l)
  "Case 4 corresponds to the case where a node Y has only one
child X. If X ∈ A[i, j, k, l] then put Y in A[i, j, k, l]. Repeat
Case 4 again if Y has no siblings."
  (push (format "tal/case-4 (%d, %d, %d, %d)" i j k l) tmp/trace)
  (labels ((test-X (X)
                   (when (and X
                              (not (bt/node-sibling X)))
                     (let ((Y (bt/node-parent X)))
                       (when Y
                         (tal/add-node-frontier Y input
                                                A i j k l)
                         (test-X Y))))))
    (loop for X in (elt (elt (elt (elt A i)
                                  j)
                             k)
                        l)
          do (test-X X))))

(defun tal/case-5 (A tag input i j k l)
  "Case 5 corresponds to adjoining. If X is a node in A[m, j, k,
p] and Y is the root of an auxiliary tree with the same symbol as
that of X, such that Y is in A[i, m, p, l]."
  (push (format "tal/case-5 (%d, %d, %d, %d)" i j k l) tmp/trace)
  (loop for m from i to k
        do
        (loop for p from m to l
              do
              (loop for Y in (remove-if-not
                              (lambda (node)
                                (find node (tal/tag-auxiliary-trees tag)))
                              (elt (elt (elt (elt A i)
                                             m)
                                        p)
                                   l))
                    do
                    (loop for X in (elt (elt (elt (elt A m)
                                                  j)
                                             k)
                                        p)
                          if (eq (bt/node-symbol X)
                                 (bt/node-symbol Y))
                          do (tal/add-node-frontier X input
                                                    A i j k l))))))

(defun tal/init-frontier (A tag input n)
  "First step of initialization of the array A.

During this step we fill A with all leaves in TAG whose label are
in the INPUT."
  (push "tal/init-frontier" tmp/trace)
  (let ((terminal-leaves (append
                          (mapcan (lambda (node)
                                    (bt/leaves node 'terminal))
                                  (tal/tag-initial-trees tag))
                          (mapcan (lambda (node)
                                    (bt/leaves node 'terminal))
                                  (tal/tag-auxiliary-trees tag)))))
    (loop for i from 0 to (1- n)
          do
          ;; put all nodes in the frontier of elementary trees whose
          ;; label is a_i+1 in A[i, i+1, i+1, i+1]
          (loop for node in terminal-leaves
                if (eq (elt input (1+ i))
                       (bt/node-symbol node))
                do
                (tal/add-node-frontier node input
                                       A i (1+ i) (1+ i) (1+ i)))))
  A)                                    ; REPL sanity

(defun tal/init-foot-nodes (A tag input n)
  "Second step of initialization of the array A.

During this step we fill A with all foot nodes from all auxiliary
trees of TAG."
  (push "tal/init-foot-nodes" tmp/trace)
  (let (;; the foot nodes are the non-terminal leaves
        (foot-nodes (loop for node in (tal/tag-auxiliary-trees tag)
                          append (bt/leaves node 'non-terminal))))
    (loop for i from 0 to n
          do
          (loop for j from i to n
                do
                ;; put foot nodes of all auxiliary trees in A[i, i, j,
                ;; j]
                (loop for node in foot-nodes
                      do (tal/add-node-frontier node input
                                                A i i j j)))))
  A)                                    ; REPL sanity

;; Utils

(defun tal/is-terminal (symbol)
  "Determine whether SYMBOL is terminal or not.

A symbol is terminal if it is in downcase, otherwise it is a
non-terminal symbol."
  (string= (symbol-name symbol)
           (downcase (symbol-name symbol))))

(defun tal/aref-m (x &rest index)
  (if (null index)
      x
    `(elt ,(tal/aref-m x (rest index))
          ,(first index))))

;; Bin Tree

(defstruct bt/node
  symbol left right parent foot-node-ancestor)

(defun bt/make-tree (list)
  "Make a binary tree made of `bt/node' from the lispy
representation in list."
  (labels ((make-tree (thing &optional parent root)
                      (unless (or (null parent)
                                  (bt/node-p parent))
                        (error "invalid PARENT (%S)" parent))
                      (unless (or (null root)
                                  (symbolp root))
                        (error "invalid ROOT (%S)" root))
                      (when thing
                        (cond ((consp thing)
                               (let ((node (make-bt/node
                                            :symbol (first thing)
                                            :parent parent)))
                                 (setf (bt/node-left node) (make-tree (second thing) node (or root (first thing)))
                                       (bt/node-right node) (make-tree (third thing) node (or root (first thing))))
                                 node))
                              ((symbolp thing)
                               (let ((node (make-bt/node :symbol thing
                                                         :parent parent)))
                                 (when (eq thing root)
                                   (mark-foot-node-ancestor node node))
                                 node)))))
           (mark-foot-node-ancestor (node foot-node)
                                    (when node
                                      (setf (bt/node-foot-node-ancestor node) foot-node)
                                      (mark-foot-node-ancestor (bt/node-parent node) foot-node))))
    (make-tree list)))

(defun bt/make-trees (lists)
  "Make trees from the list of trees represented as lisp structures.

See `bt/make-tree' for more information."
  (mapcar #'bt/make-tree lists))

(defun bt/node-sibling (node &optional side)
  "Return the sibling of NODE. SIDE can be either LEFT, RIGHT or
nil to specify the wanted sibling.

Return nil if NODE has no sibling."
  (when (bt/node-parent node)
    (let ((ret (case side
                 (left (bt/node-left (bt/node-parent node)))
                 (right (bt/node-right (bt/node-parent node)))
                 (otherwise
                  (or (bt/node-sibling node 'left)
                      (bt/node-sibling node 'right))))))
      (unless (eq ret node)
        ret))))

(defun bt/node-pp (node)
  "Pretty print NODE."
  (concat (if (bt/node-parent node)
              (symbol-name (bt/node-symbol (bt/node-parent node)))
            "_")
          " - "
          (symbol-name (bt/node-symbol node))
          " "
          (if (bt/node-left node)
              (symbol-name (bt/node-symbol (bt/node-left node)))
            "_")
          " "
          (if (bt/node-right node)
              (symbol-name (bt/node-symbol (bt/node-right node)))
            "_")))

(defun bt/is-leaf (node)
  "Determine whether NODE is a leaf.

A node is a leaf if it has no children."
  (and (not (bt/node-left node))
       (not (bt/node-right node))))

(defun bt/leaves (node &optional type)
  "Return all leaves in NODE. NODE is scanned recursively to find
all leaves.

TYPE can be TERMINAL, NON-TERMINAL or nil and is used to filter
the kind of leaves we are looking for."
  (cond ((not (bt/node-p node))
         nil)
        ((bt/is-leaf node)
         (case type
           (terminal (and (tal/is-terminal (bt/node-symbol node))
                          (list node)))
           (non-terminal (and (not (tal/is-terminal (bt/node-symbol node)))
                              (list node)))
           (otherwise (list node))))
        (t (append (bt/leaves (bt/node-left node) type)
                   (bt/leaves (bt/node-right node) type)))))

;; Initialization
(defvar tal/tag nil)
(setf tal/tag (make-tal/tag
                 :initial-trees (bt/make-trees '((S e)))
                 :auxiliary-trees (bt/make-trees '((S a (T S b))
                                                   (T a (S T b))))))

(defvar tal/input nil)
(setf tal/input '(a a e b b))

(provide 'tal-parsing)

;;; tal-parsing.el ends here
