# -*- mode: org; -*-

* Projet 4
Définir un programme prenant une grammaire TAG lexicalisée et une
chaîne de caractères en entrée et affichant si la chaîne est
analysable ou non avec la grammaire donnée. Le gros du travail va
consistera définir cet algorithme en effectuant une recherche
bibliographique sur les algorithmes d'analyse des TAG. Le programme
sera testé sur une grammaire « jouet ».

*Travail facultatif:* le programme fournira un ou tous les arbres
syntaxiques.

** Travail facultatif
Le programme fournira un ou tous les arbres syntaxiques.

* Ressources
- [[http://www.let.rug.nl/~vannoord/papers/diss/diss/node59.html][Tree Adjoining Grammars (tutorial)]]
- [[http://en.wikipedia.org/wiki/Tree-adjoining_grammar][Tree-adjoining grammar - Wikipedia, the free encyclopedia]]
- [[file:TAL%20Parsing%20In%20O(N^6)%20Time%20by%20SANGUTHEVAR%20RAJASEKARAN.pdf][TAL Parsing In O(N^6) Time by SANGUTHEVAR RAJASEKARAN.pdf]]
- [[file:TAL%20Recognition%20in%20O(M(n^2))%20Time.pdf][TAL Recognition in O(M(n^2)) Time.pdf]]

* Notes                                                            :noexport:
** CKY
Afin de mieux comprendre les algorithmes proposés pour l'analyse des
grammaires sur les Tree Adjoining Grammars, j'ai implémenté
l'algorithme CKY qui permet d'analyser les grammaires hors-contextes.

Il semblerait que l'algorithme proposé par Sanguthevar Rajasekaran
soit une variante de l'algorithme de CKY appliqué aux TAGs.

*** HOWTO use ~cky.el~?
#+BEGIN_SRC emacs-lisp
  (load-file "cky.el")
  (cky-algorithm '((S   -> NP VP)
                   (VP  -> VP PP)
                   (VP  -> V NP)
                   (VP  -> eats)
                   (PP  -> P NP)
                   (NP  -> Det N)
                   (NP  -> she)
                   (V   -> eats)
                   (P   -> with)
                   (N   -> fish)
                   (N   -> fork)
                   (Det -> a))
                 '(she eats a fish with a fork))
#+END_SRC

#+RESULTS:
| (NP)   | (S)  | nil  | (S) | nil | nil  | (S) |
| (V VP) | nil  | (VP) | nil | nil | (VP) | nil |
| (Det)  | (NP) | nil  | nil | nil | nil  | nil |
| (N)    | nil  | nil  | nil | nil | nil  | nil |
| (P)    | nil  | (PP) | nil | nil | nil  | nil |
| (Det)  | (NP) | nil  | nil | nil | nil  | nil |
| (N)    | nil  | nil  | nil | nil | nil  | nil |

** Earley

Peut-être que j'implémenterais l'algorithme de Earley...

** TAL parsing
I think I know what's wrong with my current implementation.

I have to ensure that the correct properties are satisfied before
adding a node to the array A. That is, I have to make sure that it's
frontier is a substring of the input given the i, j, k, l indices (cf
p216).

That's probably why I have too many wrong results but not why some
inputs aren't properly parsed (e.g. "aeb").
